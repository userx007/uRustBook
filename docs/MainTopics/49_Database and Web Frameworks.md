# Database and Web Frameworks in Rust

I'll create a comprehensive guide covering Rust's database libraries and web frameworks with practical examples.I've created a comprehensive guide covering Rust's database and web frameworks. Here's what's included:

## Key Highlights:

**Database Libraries:**
- **SQLx** - Async-first with compile-time SQL verification using macros. Great for raw SQL queries and microservices
- **Diesel** - Type-safe ORM with a powerful DSL. Best for complex queries and strong compile-time guarantees

**Connection Pooling:**
- Examples with SQLx's built-in pooling, R2D2 for Diesel, and Deadpool for flexibility
- Configuration options for pool size, timeouts, and connection lifecycle

**Web Frameworks:**
- **Axum** - Modern and ergonomic, minimal boilerplate, built by the Tokio team
- **Actix-web** - Highest performance, mature ecosystem, battle-tested
- **Rocket** - Most developer-friendly, macro-based routing, easiest to learn

**Async Patterns:**
- Streaming responses and Server-Sent Events
- Background task handling
- Graceful shutdown patterns
- Concurrent request processing
- Production-ready error handling

Each section includes complete, runnable examples showing real-world patterns. The guide also includes comparison tables to help you choose the right tool for your specific use case.

The examples demonstrate how these technologies work together - like using SQLx with Axum for a complete REST API with proper connection pooling and error handling.

# Rust Database and Web Frameworks

## Database Libraries

### SQLx - Async, Compile-Time Verified SQL

SQLx is a pure Rust SQL toolkit that provides compile-time checked queries without requiring a DSL (Domain-Specific Language).

**Key Features:**
- Async/await support
- Compile-time query verification
- Direct SQL queries
- Supports PostgreSQL, MySQL, SQLite, and MSSQL
- Runtime-agnostic (works with tokio, async-std)

**Basic Example:**

```rust
use sqlx::postgres::PgPoolOptions;
use sqlx::{FromRow, Pool, Postgres};

#[derive(FromRow, Debug)]
struct User {
    id: i32,
    username: String,
    email: String,
}

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    // Create connection pool
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://user:pass@localhost/mydb")
        .await?;

    // Insert with query!() macro - compile-time checked
    sqlx::query!(
        "INSERT INTO users (username, email) VALUES ($1, $2)",
        "john_doe",
        "john@example.com"
    )
    .execute(&pool)
    .await?;

    // Query with automatic deserialization
    let users: Vec<User> = sqlx::query_as!(
        User,
        "SELECT id, username, email FROM users WHERE id > $1",
        0
    )
    .fetch_all(&pool)
    .await?;

    for user in users {
        println!("{:?}", user);
    }

    Ok(())
}
```

**Transaction Example:**

```rust
async fn transfer_funds(
    pool: &Pool<Postgres>,
    from_id: i32,
    to_id: i32,
    amount: f64,
) -> Result<(), sqlx::Error> {
    let mut tx = pool.begin().await?;

    sqlx::query!(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        amount,
        from_id
    )
    .execute(&mut *tx)
    .await?;

    sqlx::query!(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        amount,
        to_id
    )
    .execute(&mut *tx)
    .await?;

    tx.commit().await?;
    Ok(())
}
```

### Diesel - Type-Safe ORM

Diesel is a safe, extensible ORM and query builder that prevents runtime errors through compile-time guarantees.

**Key Features:**
- Type-safe query builder
- Schema-based approach
- Excellent compile-time guarantees
- Blocking by default (async via diesel-async)
- Powerful DSL for complex queries

**Basic Example:**

```rust
// schema.rs (generated by diesel CLI)
table! {
    users (id) {
        id -> Int4,
        username -> Varchar,
        email -> Varchar,
        created_at -> Timestamp,
    }
}

// models.rs
use diesel::prelude::*;
use crate::schema::users;

#[derive(Queryable, Selectable, Debug)]
#[diesel(table_name = users)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub email: String,
    pub created_at: chrono::NaiveDateTime,
}

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub username: &'a str,
    pub email: &'a str,
}

// main.rs
use diesel::pg::PgConnection;
use diesel::prelude::*;
use dotenvy::dotenv;
use std::env;

fn establish_connection() -> PgConnection {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url)
        .expect("Error connecting to database")
}

fn create_user(conn: &mut PgConnection, username: &str, email: &str) -> User {
    use crate::schema::users;

    let new_user = NewUser { username, email };

    diesel::insert_into(users::table)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
        .expect("Error saving new user")
}

fn get_users(conn: &mut PgConnection) -> Vec<User> {
    use crate::schema::users::dsl::*;

    users
        .filter(id.gt(0))
        .limit(10)
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}
```

**Complex Query Example:**

```rust
use diesel::prelude::*;

fn find_users_with_recent_posts(
    conn: &mut PgConnection,
    days: i32,
) -> QueryResult<Vec<(User, Post)>> {
    use crate::schema::{users, posts};

    users::table
        .inner_join(posts::table)
        .filter(posts::created_at.gt(diesel::dsl::now - days.days()))
        .select((User::as_select(), Post::as_select()))
        .load::<(User, Post)>(conn)
}
```

### SQLx vs Diesel Comparison

| Feature | SQLx | Diesel |
|---------|------|--------|
| Query Style | Raw SQL | DSL/Query Builder |
| Async Support | Native | Via diesel-async |
| Learning Curve | Lower | Higher |
| Flexibility | High (raw SQL) | Medium (DSL) |
| Type Safety | Compile-time (with macros) | Compile-time (always) |
| Migrations | Built-in | CLI tool |
| Best For | Simple queries, microservices | Complex queries, ORM features |

## Connection Pooling

Connection pooling is essential for web applications to efficiently manage database connections.

### SQLx Connection Pool

```rust
use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

async fn create_pool() -> Result<sqlx::PgPool, sqlx::Error> {
    let pool = PgPoolOptions::new()
        .max_connections(20)              // Maximum connections
        .min_connections(5)               // Minimum idle connections
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .connect("postgres://user:pass@localhost/mydb")
        .await?;
    
    Ok(pool)
}

// Using the pool
async fn handle_request(pool: &sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Automatically acquires and releases connection
    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", 1)
        .fetch_one(pool)
        .await?;
    
    Ok(())
}
```

### R2D2 with Diesel

```rust
use diesel::r2d2::{self, ConnectionManager};
use diesel::pg::PgConnection;

type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;

fn create_pool(database_url: &str) -> DbPool {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    r2d2::Pool::builder()
        .max_size(15)
        .min_idle(Some(5))
        .build(manager)
        .expect("Failed to create pool")
}

fn handle_request(pool: &DbPool) -> QueryResult<Vec<User>> {
    let mut conn = pool.get().expect("Failed to get connection");
    
    use crate::schema::users::dsl::*;
    users.load::<User>(&mut conn)
}
```

### Deadpool (Generic Pool)

```rust
use deadpool_postgres::{Config, Pool, Runtime};
use tokio_postgres::NoTls;

async fn create_deadpool() -> Pool {
    let mut cfg = Config::new();
    cfg.host = Some("localhost".to_string());
    cfg.user = Some("postgres".to_string());
    cfg.password = Some("password".to_string());
    cfg.dbname = Some("mydb".to_string());
    
    cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap()
}
```

## Web Frameworks

### Axum - Modern, Ergonomic

Axum is built on top of hyper and tower, designed by the tokio team for ergonomic async web services.

**Key Features:**
- Minimal boilerplate
- Excellent type inference
- Tower middleware ecosystem
- Compile-time routing validation
- WebSocket support

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::sync::Arc;

// Shared application state
#[derive(Clone)]
struct AppState {
    db: PgPool,
}

#[derive(Serialize, Deserialize)]
struct User {
    id: i32,
    username: String,
    email: String,
}

#[derive(Deserialize)]
struct CreateUser {
    username: String,
    email: String,
}

#[derive(Deserialize)]
struct Pagination {
    page: Option<i32>,
    per_page: Option<i32>,
}

// Handler functions
async fn list_users(
    State(state): State<Arc<AppState>>,
    Query(pagination): Query<Pagination>,
) -> Result<Json<Vec<User>>, StatusCode> {
    let page = pagination.page.unwrap_or(1);
    let per_page = pagination.per_page.unwrap_or(10);
    let offset = (page - 1) * per_page;

    let users = sqlx::query_as!(
        User,
        "SELECT id, username, email FROM users LIMIT $1 OFFSET $2",
        per_page as i64,
        offset as i64
    )
    .fetch_all(&state.db)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(users))
}

async fn get_user(
    State(state): State<Arc<AppState>>,
    Path(user_id): Path<i32>,
) -> Result<Json<User>, StatusCode> {
    let user = sqlx::query_as!(
        User,
        "SELECT id, username, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(&state.db)
    .await
    .map_err(|_| StatusCode::NOT_FOUND)?;

    Ok(Json(user))
}

async fn create_user(
    State(state): State<Arc<AppState>>,
    Json(payload): Json<CreateUser>,
) -> Result<(StatusCode, Json<User>), StatusCode> {
    let user = sqlx::query_as!(
        User,
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING id, username, email",
        payload.username,
        payload.email
    )
    .fetch_one(&state.db)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok((StatusCode::CREATED, Json(user)))
}

#[tokio::main]
async fn main() {
    let pool = sqlx::postgres::PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://user:pass@localhost/mydb")
        .await
        .expect("Failed to create pool");

    let app_state = Arc::new(AppState { db: pool });

    let app = Router::new()
        .route("/users", get(list_users).post(create_user))
        .route("/users/:id", get(get_user))
        .with_state(app_state);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    println!("Server running on http://localhost:3000");
    axum::serve(listener, app).await.unwrap();
}
```

**Middleware Example:**

```rust
use axum::{
    middleware::{self, Next},
    http::Request,
    response::Response,
};
use tower::ServiceBuilder;

async fn auth_middleware<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req.headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok());

    match auth_header {
        Some(token) if token.starts_with("Bearer ") => {
            Ok(next.run(req).await)
        }
        _ => Err(StatusCode::UNAUTHORIZED),
    }
}

fn create_protected_routes() -> Router<Arc<AppState>> {
    Router::new()
        .route("/protected", get(protected_handler))
        .layer(middleware::from_fn(auth_middleware))
}
```

### Actix-web - High Performance

Actix-web is one of the fastest Rust web frameworks, built on the actor model.

**Key Features:**
- Extremely fast
- Mature ecosystem
- Built-in WebSocket support
- Flexible middleware
- Request extractors

```rust
use actix_web::{web, App, HttpResponse, HttpServer, Responder};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;

#[derive(Serialize, Deserialize)]
struct User {
    id: i32,
    username: String,
    email: String,
}

#[derive(Deserialize)]
struct CreateUser {
    username: String,
    email: String,
}

struct AppState {
    db: PgPool,
}

async fn list_users(data: web::Data<AppState>) -> impl Responder {
    match sqlx::query_as!(User, "SELECT id, username, email FROM users")
        .fetch_all(&data.db)
        .await
    {
        Ok(users) => HttpResponse::Ok().json(users),
        Err(_) => HttpResponse::InternalServerError().finish(),
    }
}

async fn get_user(
    path: web::Path<i32>,
    data: web::Data<AppState>,
) -> impl Responder {
    let user_id = path.into_inner();
    
    match sqlx::query_as!(
        User,
        "SELECT id, username, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(&data.db)
    .await
    {
        Ok(user) => HttpResponse::Ok().json(user),
        Err(_) => HttpResponse::NotFound().finish(),
    }
}

async fn create_user(
    user: web::Json<CreateUser>,
    data: web::Data<AppState>,
) -> impl Responder {
    match sqlx::query_as!(
        User,
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING id, username, email",
        user.username,
        user.email
    )
    .fetch_one(&data.db)
    .await
    {
        Ok(user) => HttpResponse::Created().json(user),
        Err(_) => HttpResponse::InternalServerError().finish(),
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let pool = sqlx::postgres::PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://user:pass@localhost/mydb")
        .await
        .expect("Failed to create pool");

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(AppState { db: pool.clone() }))
            .route("/users", web::get().to(list_users))
            .route("/users", web::post().to(create_user))
            .route("/users/{id}", web::get().to(get_user))
    })
    .bind(("127.0.0.1", 8080))?
    .run()
    .await
}
```

**Middleware Example:**

```rust
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use actix_web_httpauth::extractors::bearer::BearerAuth;

async fn validator(
    req: ServiceRequest,
    credentials: BearerAuth,
) -> Result<ServiceRequest, (Error, ServiceRequest)> {
    if credentials.token() == "valid_token" {
        Ok(req)
    } else {
        Err((actix_web::error::ErrorUnauthorized("Invalid token"), req))
    }
}
```

### Rocket - Developer-Friendly

Rocket focuses on ease of use and developer productivity with its macro-based approach.

**Key Features:**
- Intuitive API
- Type-safe routing
- Built-in form handling
- Extensive validation
- Template support

```rust
#[macro_use] extern crate rocket;

use rocket::{State, serde::json::Json};
use rocket::http::Status;
use serde::{Deserialize, Serialize};
use sqlx::PgPool;

#[derive(Serialize, Deserialize)]
struct User {
    id: i32,
    username: String,
    email: String,
}

#[derive(Deserialize)]
struct CreateUser {
    username: String,
    email: String,
}

#[get("/users")]
async fn list_users(db: &State<PgPool>) -> Result<Json<Vec<User>>, Status> {
    sqlx::query_as!(User, "SELECT id, username, email FROM users")
        .fetch_all(db.inner())
        .await
        .map(Json)
        .map_err(|_| Status::InternalServerError)
}

#[get("/users/<id>")]
async fn get_user(id: i32, db: &State<PgPool>) -> Result<Json<User>, Status> {
    sqlx::query_as!(
        User,
        "SELECT id, username, email FROM users WHERE id = $1",
        id
    )
    .fetch_one(db.inner())
    .await
    .map(Json)
    .map_err(|_| Status::NotFound)
}

#[post("/users", data = "<user>")]
async fn create_user(
    user: Json<CreateUser>,
    db: &State<PgPool>,
) -> Result<Json<User>, Status> {
    sqlx::query_as!(
        User,
        "INSERT INTO users (username, email) VALUES ($1, $2) RETURNING id, username, email",
        user.username,
        user.email
    )
    .fetch_one(db.inner())
    .await
    .map(Json)
    .map_err(|_| Status::InternalServerError)
}

#[launch]
async fn rocket() -> _ {
    let pool = sqlx::postgres::PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://user:pass@localhost/mydb")
        .await
        .expect("Failed to create pool");

    rocket::build()
        .manage(pool)
        .mount("/", routes![list_users, get_user, create_user])
}
```

## Async Web Patterns

### Streaming Responses

```rust
use axum::{
    body::Body,
    response::{IntoResponse, Response},
};
use futures::stream::{self, StreamExt};

async fn stream_data() -> Response {
    let stream = stream::iter(0..100)
        .map(|i| Ok::<_, std::io::Error>(format!("Item {}\n", i)));

    Body::from_stream(stream).into_response()
}
```

### Server-Sent Events (SSE)

```rust
use axum::{
    response::sse::{Event, Sse},
};
use futures::stream::{self, Stream};
use std::time::Duration;
use tokio::time::sleep;

async fn sse_handler() -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    let stream = stream::repeat_with(|| Event::default().data("ping"))
        .throttle(Duration::from_secs(1));

    Sse::new(stream)
}
```

### Background Tasks

```rust
use tokio::spawn;

async fn handle_with_background_task(
    State(state): State<Arc<AppState>>,
    Json(data): Json<CreateUser>,
) -> Result<StatusCode, StatusCode> {
    // Process immediately
    let user_id = create_user_in_db(&state.db, &data).await?;

    // Spawn background task
    let db = state.db.clone();
    spawn(async move {
        send_welcome_email(db, user_id).await;
    });

    Ok(StatusCode::CREATED)
}
```

### Graceful Shutdown

```rust
use tokio::signal;

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    println!("Shutdown signal received, closing connections...");
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .unwrap();
}
```

### Concurrency Patterns

```rust
use futures::future::join_all;

async fn fetch_multiple_resources(ids: Vec<i32>, db: &PgPool) -> Vec<User> {
    let futures = ids.into_iter().map(|id| {
        sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", id)
            .fetch_one(db)
    });

    join_all(futures)
        .await
        .into_iter()
        .filter_map(Result::ok)
        .collect()
}
```

## Best Practices

### Error Handling

```rust
use thiserror::Error;
use axum::{response::IntoResponse, http::StatusCode};

#[derive(Error, Debug)]
enum AppError {
    #[error("Database error")]
    Database(#[from] sqlx::Error),
    
    #[error("Not found")]
    NotFound,
    
    #[error("Validation error: {0}")]
    Validation(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Database error"),
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found"),
            AppError::Validation(msg) => (StatusCode::BAD_REQUEST, &msg),
        };

        (status, message).into_response()
    }
}

async fn handler(db: &PgPool, id: i32) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", id)
        .fetch_one(db)
        .await
        .map_err(|_| AppError::NotFound)?;

    Ok(Json(user))
}
```

### Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::to_bytes;
    use axum::http::{Request, StatusCode};
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_list_users() {
        let pool = create_test_pool().await;
        let app = create_app(pool);

        let response = app
            .oneshot(Request::builder().uri("/users").body(Body::empty()).unwrap())
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }
}
```

## Framework Comparison

| Feature | Axum | Actix-web | Rocket |
|---------|------|-----------|--------|
| Performance | Very High | Highest | High |
| Learning Curve | Low | Medium | Low |
| Async | Native | Native | Native (v0.5+) |
| Type Safety | Excellent | Good | Excellent |
| Ecosystem | Growing | Mature | Mature |
| Documentation | Good | Excellent | Excellent |
| Best For | Modern apps | High-performance | Quick prototyping |

## Conclusion

Choose your tools based on your needs:
- **SQLx**: Raw SQL, compile-time safety, async-first
- **Diesel**: ORM, complex queries, type-safety
- **Axum**: Modern, minimal boilerplate, great DX
- **Actix-web**: Maximum performance, mature
- **Rocket**: Easiest to learn, rapid development

All these tools integrate well together and support production-grade applications.